#%%旋转轮廓 每个轮廓分别填充√√√
import cv2
import numpy as np
import os
from scipy.spatial import distance
import matplotlib.pyplot as plt

def get_boundaries_and_centroid(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY)
    if binary is None or binary.size == 0:
        print("二值图像创建失败")
        return None, None, None

    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if len(contours) == 0:
        print("图像中未找到轮廓")
        return None, None, binary

    all_points = np.vstack(contours)
    M = cv2.moments(all_points)
    if M["m00"] != 0:
        cx = int(M["m10"] / M["m00"])
        cy = int(M["m01"] / M["m00"])
    else:
        cx, cy = 0, 0
    centroid = (cx, cy)
    
    return contours, centroid, binary

def find_farthest_point(contours, centroid):
    points = np.vstack(contours)[:, 0, :]
    dists = distance.cdist([centroid], points)[0]
    max_dist_index = np.argmax(dists)
    farthest_point = points[max_dist_index]
    return tuple(farthest_point)

def rotate_points_around_centroid(points, centroid, angle):
    angle_rad = np.radians(angle)
    cos_angle = np.cos(angle_rad)
    sin_angle = np.sin(angle_rad)
    
    rotated_points = []
    for point in points:
        x, y = point
        cx, cy = centroid
        x -= cx
        y -= cy
        
        x_new = x * cos_angle - y * sin_angle
        y_new = x * sin_angle + y * cos_angle
        
        x_new += cx
        y_new += cy
        rotated_points.append((x_new, y_new))
    
    return np.array(rotated_points, dtype=np.int32)

def calculate_bounding_box(points):
    x_min, y_min = np.min(points, axis=0)
    x_max, y_max = np.max(points, axis=0)
    return int(x_min), int(y_min), int(x_max), int(y_max)

def visualize_contours_and_centroid(image, contours, centroid):
    visualized_image = image.copy()
    cv2.drawContours(visualized_image, contours, -1, (0, 255, 0), 2)  # 绘制轮廓为绿色
    cv2.circle(visualized_image, centroid, 5, (0, 0, 255), -1)  # 绘制质心为红色圆点
    return visualized_image

def visualize_rotated_points(rotated_image):
    plt.figure(figsize=(8, 8))  # 设置图像大小
    plt.imshow(rotated_image)
    plt.title('Rotated Contours Visualization')  # 设置标题
    plt.axis('off')  # 关闭坐标轴
    plt.show()  # 显示图像

def process_images(input_folder, output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
        
    for filename in os.listdir(input_folder):
        if filename.endswith('.png') or filename.endswith('.jpg') or filename.endswith('.tif'):
            img_path = os.path.join(input_folder, filename)
            image = cv2.imread(img_path)
            if image is None:
                print(f"无法加载图像：{img_path}")
                continue
            
            contours, centroid, binary = get_boundaries_and_centroid(image)
            if contours is None or centroid is None:
                print(f"由于处理失败，跳过图像：{img_path}")
                continue
            
            farthest_point = find_farthest_point(contours, centroid)
            
            delta_x = farthest_point[0] - centroid[0]
            delta_y = farthest_point[1] - centroid[1]
            angle = np.degrees(np.arctan2(delta_y, delta_x))
            
            rotated_contours = []
            for contour in contours:
                points = contour[:, 0, :]
                rotated_points = rotate_points_around_centroid(points, centroid, -angle)
                rotated_contours.append(rotated_points)
            
            # 计算所有旋转后的轮廓点的包围框
            all_rotated_points = np.vstack(rotated_contours)
            x_min, y_min, x_max, y_max = calculate_bounding_box(all_rotated_points)
            rotated_image = np.zeros((y_max - y_min + 1, x_max - x_min + 1, 3), dtype=np.uint8)
            
            # 计算旋转后的质心和最远点
            rotated_centroid = rotate_points_around_centroid([centroid], centroid, -angle)[0]
            rotated_farthest_point = rotate_points_around_centroid([farthest_point], centroid, -angle)[0]
            
            # 绘制旋转后的轮廓
            for rotated_points in rotated_contours:
                rotated_points[:, 0] -= x_min
                rotated_points[:, 1] -= y_min
                
                rotated_points = rotated_points.reshape((-1, 1, 2))
                cv2.fillPoly(rotated_image, [rotated_points], (255, 255, 255))
            
            rotated_output_path = os.path.join(output_folder, f"{os.path.splitext(filename)[0]}_spinning.png")
            cv2.imwrite(rotated_output_path, rotated_image)
            print(f"已处理并保存：{rotated_output_path}")

            # 垂直翻转
            flipped_image = cv2.flip(rotated_image, 0)
            flip_output_path = os.path.join(output_folder, f"{os.path.splitext(filename)[0]}_flip.png")
            cv2.imwrite(flip_output_path, flipped_image)
            print(f"已保存垂直翻转后的图像：{flip_output_path}")

            # 水平翻转
            horizontal_flip_image = cv2.flip(rotated_image, 1)
            horizontal_flip_output_path = os.path.join(output_folder, f"{os.path.splitext(filename)[0]}_spinning_hflip.png")
            cv2.imwrite(horizontal_flip_output_path, horizontal_flip_image)
            print(f"已保存旋转后水平翻转的图像：{horizontal_flip_output_path}")

            horizontal_flip_image_flip = cv2.flip(flipped_image, 1)
            horizontal_flip_flip_output_path = os.path.join(output_folder, f"{os.path.splitext(filename)[0]}_flip_hflip.png")
            cv2.imwrite(horizontal_flip_flip_output_path, horizontal_flip_image_flip)
            print(f"已保存垂直翻转后水平翻转的图像：{horizontal_flip_flip_output_path}")

if __name__ == "__main__":
    # input_folder = "G:/snm/embryo3D/24H_AntherS1_2.07um_recon_Export/zoo/09-tissueSeqBinary/zoo1"
    # input_folder = "G:/snm/embryo3D/24H_AntherS1_2.07um_recon_Export/zoo/10/zoo2"
    # input_folder = "G:/snm/embryo3D/24H_AntherS1_2.07um_recon_Export/zoo/09-tissueSeqBinary/zoo1/spinning01/GT"
    # input_folder = "G:/snm/embryo3D/24H_AntherS1_2.07um_recon_Export/zoo/3DRiceSeedPRJT/data/ST-slide/24HAI_2/mask2"
    input_folder = "G:/snm/embryo3D/24H_AntherS1_2.07um_recon_Export/zoo/3DRiceSeedPRJT/data/ST-slide/round3/mask"

    output_folder = f"{input_folder}/spinning"
    process_images(input_folder, output_folder)

# %%
